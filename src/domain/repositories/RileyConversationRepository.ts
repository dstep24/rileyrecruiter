/**
 * Riley Conversation Repository
 *
 * Handles persistence of Riley-initiated LinkedIn conversations.
 * Used to track which conversations Riley started, so we only auto-respond
 * to those conversations (not random LinkedIn messages).
 */

import { prisma } from '../../infrastructure/database/prisma.js';
import type {
  RileyConversation,
  RileyMessage,
  RileyConversationStage,
  RileyConversationStatus,
  MessageRole,
} from '../../generated/prisma/index.js';

// =============================================================================
// TYPES
// =============================================================================

export interface CreateConversationInput {
  chatId: string;
  candidateProviderId: string;
  candidateName?: string;
  candidateTitle?: string;
  candidateCompany?: string;
  candidateProfileUrl?: string;
  jobRequisitionId?: string;
  jobTitle?: string;
  initialMessage: string;
}

export interface ConversationWithMessages extends RileyConversation {
  messages: RileyMessage[];
}

export interface ListOptions {
  limit?: number;
  status?: RileyConversationStatus;
  stage?: RileyConversationStage;
}

// =============================================================================
// REPOSITORY
// =============================================================================

export class RileyConversationRepository {

  /**
   * Create a new Riley-initiated conversation.
   * Called when Riley sends initial outreach to a candidate.
   */
  async createFromOutreach(data: CreateConversationInput): Promise<RileyConversation> {
    return prisma.rileyConversation.create({
      data: {
        chatId: data.chatId,
        candidateProviderId: data.candidateProviderId,
        candidateName: data.candidateName,
        candidateTitle: data.candidateTitle,
        candidateCompany: data.candidateCompany,
        candidateProfileUrl: data.candidateProfileUrl,
        jobRequisitionId: data.jobRequisitionId,
        jobTitle: data.jobTitle,
        stage: 'AWAITING_RESPONSE',
        lastMessageBy: 'RILEY',
        messages: {
          create: {
            role: 'RILEY' as MessageRole,
            content: data.initialMessage,
            isAutoGenerated: false,
          },
        },
      },
    });
  }

  /**
   * Check if a chat is Riley-initiated.
   * This is the key filter - only process messages from Riley-initiated chats.
   */
  async isRileyInitiated(chatId: string): Promise<boolean> {
    const conv = await prisma.rileyConversation.findUnique({
      where: { chatId },
      select: { id: true },
    });
    return conv !== null;
  }

  /**
   * Get conversation by Unipile chat ID.
   */
  async getByChatId(chatId: string): Promise<ConversationWithMessages | null> {
    return prisma.rileyConversation.findUnique({
      where: { chatId },
      include: {
        messages: {
          orderBy: { createdAt: 'asc' },
        },
      },
    });
  }

  /**
   * Get conversation by ID.
   */
  async getById(id: string): Promise<ConversationWithMessages | null> {
    return prisma.rileyConversation.findUnique({
      where: { id },
      include: {
        messages: {
          orderBy: { createdAt: 'asc' },
        },
      },
    });
  }

  /**
   * Add an incoming message from the candidate.
   */
  async addCandidateMessage(
    chatId: string,
    content: string,
    unipileMessageId?: string
  ): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: {
        lastMessageAt: new Date(),
        lastMessageBy: 'CANDIDATE',
        messageCount: { increment: 1 },
        stage: 'IN_CONVERSATION',
        messages: {
          create: {
            role: 'CANDIDATE' as MessageRole,
            content,
            unipileMessageId,
            isAutoGenerated: false,
          },
        },
      },
    });
  }

  /**
   * Add Riley's auto-response message.
   */
  async addRileyResponse(
    chatId: string,
    content: string,
    unipileMessageId?: string
  ): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: {
        lastMessageAt: new Date(),
        lastMessageBy: 'RILEY',
        messageCount: { increment: 1 },
        messages: {
          create: {
            role: 'RILEY' as MessageRole,
            content,
            unipileMessageId,
            isAutoGenerated: true,
          },
        },
      },
    });
  }

  /**
   * Add a teleoperator message (manual override).
   */
  async addTeleoperatorMessage(
    chatId: string,
    content: string,
    unipileMessageId?: string
  ): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: {
        lastMessageAt: new Date(),
        lastMessageBy: 'TELEOPERATOR',
        messageCount: { increment: 1 },
        // Clear escalation since human took over
        isEscalated: false,
        escalationReason: null,
        messages: {
          create: {
            role: 'TELEOPERATOR' as MessageRole,
            content,
            unipileMessageId,
            isAutoGenerated: false,
          },
        },
      },
    });
  }

  /**
   * Update conversation stage.
   */
  async updateStage(chatId: string, stage: RileyConversationStage): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: { stage },
    });
  }

  /**
   * Mark conversation as escalated.
   */
  async escalate(chatId: string, reason: string): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: {
        status: 'ESCALATED',
        isEscalated: true,
        escalationReason: reason,
      },
    });
  }

  /**
   * Mark conversation as paused.
   */
  async pause(chatId: string): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: { status: 'PAUSED' },
    });
  }

  /**
   * Resume a paused conversation.
   */
  async resume(chatId: string): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: {
        status: 'ACTIVE',
        isEscalated: false,
        escalationReason: null,
      },
    });
  }

  /**
   * Mark scheduling as requested (candidate wants to book a call).
   */
  async markSchedulingRequested(chatId: string): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: {
        schedulingRequested: true,
        stage: 'SCHEDULING',
      },
    });
  }

  /**
   * Mark call as scheduled.
   */
  async markScheduled(chatId: string, scheduledAt: Date): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: {
        scheduledCallAt: scheduledAt,
        stage: 'SCHEDULED',
        status: 'COMPLETED',
      },
    });
  }

  /**
   * Close conversation with outcome.
   */
  async close(
    chatId: string,
    outcome: 'CLOSED_INTERESTED' | 'CLOSED_NOT_INTERESTED' | 'CLOSED_NO_RESPONSE'
  ): Promise<RileyConversation> {
    return prisma.rileyConversation.update({
      where: { chatId },
      data: {
        stage: outcome,
        status: 'COMPLETED',
      },
    });
  }

  /**
   * List active conversations for dashboard.
   */
  async listActive(options?: ListOptions): Promise<ConversationWithMessages[]> {
    const where: {
      status?: RileyConversationStatus;
      stage?: RileyConversationStage;
    } = {};

    if (options?.status) {
      where.status = options.status;
    } else {
      where.status = 'ACTIVE';
    }

    if (options?.stage) {
      where.stage = options.stage;
    }

    return prisma.rileyConversation.findMany({
      where,
      include: {
        messages: {
          orderBy: { createdAt: 'desc' },
          take: 1, // Just the latest message for list view
        },
      },
      orderBy: { lastMessageAt: 'desc' },
      take: options?.limit || 50,
    });
  }

  /**
   * List escalated conversations requiring attention.
   */
  async listEscalated(limit?: number): Promise<ConversationWithMessages[]> {
    return prisma.rileyConversation.findMany({
      where: {
        status: 'ESCALATED',
        isEscalated: true,
      },
      include: {
        messages: {
          orderBy: { createdAt: 'desc' },
          take: 3, // Show recent context
        },
      },
      orderBy: { lastMessageAt: 'desc' },
      take: limit || 20,
    });
  }

  /**
   * List all conversations (for dashboard overview).
   */
  async listAll(options?: ListOptions): Promise<ConversationWithMessages[]> {
    const where: {
      status?: RileyConversationStatus;
      stage?: RileyConversationStage;
    } = {};

    if (options?.status) {
      where.status = options.status;
    }

    if (options?.stage) {
      where.stage = options.stage;
    }

    return prisma.rileyConversation.findMany({
      where: Object.keys(where).length > 0 ? where : undefined,
      include: {
        messages: {
          orderBy: { createdAt: 'asc' },
        },
      },
      orderBy: { lastMessageAt: 'desc' },
      take: options?.limit || 100,
    });
  }

  /**
   * Get conversation stats for dashboard.
   */
  async getStats(): Promise<{
    total: number;
    active: number;
    escalated: number;
    scheduled: number;
    awaitingResponse: number;
  }> {
    const [total, active, escalated, scheduled, awaitingResponse] = await Promise.all([
      prisma.rileyConversation.count(),
      prisma.rileyConversation.count({ where: { status: 'ACTIVE' } }),
      prisma.rileyConversation.count({ where: { status: 'ESCALATED' } }),
      prisma.rileyConversation.count({ where: { stage: 'SCHEDULED' } }),
      prisma.rileyConversation.count({ where: { stage: 'AWAITING_RESPONSE' } }),
    ]);

    return { total, active, escalated, scheduled, awaitingResponse };
  }
}

// Export singleton instance
export const rileyConversationRepo = new RileyConversationRepository();
