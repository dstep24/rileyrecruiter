/**
 * ConversationService - Manages candidate conversations and Riley's auto-responses
 *
 * This service handles:
 * - Tracking conversation threads with candidates
 * - Generating AI-powered responses via Claude
 * - Managing outreach sequences (initial message → follow-ups)
 * - Escalation to teleoperators for sensitive topics
 */

import { v4 as uuid } from 'uuid';

// =============================================================================
// TYPES
// =============================================================================

export interface Conversation {
  id: string;
  chatId: string; // Unipile chat ID
  candidateId?: string; // Our internal candidate ID
  candidateProviderId: string; // LinkedIn provider ID
  candidateName: string;
  candidateTitle?: string;
  candidateCompany?: string;
  candidateProfileUrl?: string;

  // Context
  jobRequisitionId?: string;
  jobTitle?: string;
  stage: ConversationStage;

  // Message tracking
  messages: ConversationMessage[];
  lastMessageAt: Date;
  lastMessageBy: 'riley' | 'candidate' | 'teleoperator';

  // Sequence tracking
  outreachSequenceStep?: number;
  nextFollowUpAt?: Date;

  // Status
  status: 'active' | 'paused' | 'completed' | 'escalated';
  escalationReason?: string;

  // Metadata
  createdAt: Date;
  updatedAt: Date;
}

export interface ConversationMessage {
  id: string;
  role: 'riley' | 'candidate' | 'teleoperator';
  content: string;
  timestamp: Date;
  metadata?: {
    messageId?: string; // Unipile message ID
    isAutoGenerated?: boolean;
    generationModel?: string;
    wasEscalated?: boolean;
  };
}

export type ConversationStage =
  | 'initial_outreach' // First message sent
  | 'awaiting_response' // Waiting for candidate to reply
  | 'in_conversation' // Active back-and-forth
  | 'scheduling' // Discussing interview scheduling
  | 'follow_up' // Follow-up after no response
  | 'closed_interested' // Candidate interested, handed off
  | 'closed_not_interested' // Candidate declined
  | 'closed_no_response'; // No response after sequence

export interface ResponseGenerationContext {
  conversation: Conversation;
  incomingMessage: string;
  candidateProfile?: {
    headline?: string;
    currentTitle?: string;
    currentCompany?: string;
    location?: string;
    summary?: string;
    experiences?: Array<{
      title: string;
      company: string;
      duration?: string;
    }>;
  };
  jobContext?: {
    title: string;
    company?: string;
    location?: string;
    highlights?: string[];
  };
  guidelines?: {
    brandVoice?: string;
    messageLength?: 'short' | 'medium' | 'long';
    avoidPhrases?: string[];
  };
}

export interface GeneratedResponse {
  message: string;
  confidence: number;
  reasoning: string;
  suggestedStage?: ConversationStage;
  requiresEscalation: boolean;
  escalationReason?: string;
}

// =============================================================================
// IN-MEMORY STORE (replace with database in production)
// =============================================================================

const conversations: Map<string, Conversation> = new Map();
const conversationsByChatId: Map<string, string> = new Map(); // chatId → conversationId

// =============================================================================
// SERVICE
// =============================================================================

export class ConversationService {
  /**
   * Create or get a conversation for a candidate
   */
  async getOrCreateConversation(params: {
    chatId: string;
    candidateProviderId: string;
    candidateName: string;
    candidateTitle?: string;
    candidateCompany?: string;
    candidateProfileUrl?: string;
    jobRequisitionId?: string;
    jobTitle?: string;
  }): Promise<Conversation> {
    // Check if conversation already exists
    const existingId = conversationsByChatId.get(params.chatId);
    if (existingId) {
      const existing = conversations.get(existingId);
      if (existing) {
        return existing;
      }
    }

    // Create new conversation
    const conversation: Conversation = {
      id: uuid(),
      chatId: params.chatId,
      candidateProviderId: params.candidateProviderId,
      candidateName: params.candidateName,
      candidateTitle: params.candidateTitle,
      candidateCompany: params.candidateCompany,
      candidateProfileUrl: params.candidateProfileUrl,
      jobRequisitionId: params.jobRequisitionId,
      jobTitle: params.jobTitle,
      stage: 'initial_outreach',
      messages: [],
      lastMessageAt: new Date(),
      lastMessageBy: 'riley',
      status: 'active',
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    conversations.set(conversation.id, conversation);
    conversationsByChatId.set(params.chatId, conversation.id);

    return conversation;
  }

  /**
   * Get conversation by chat ID
   */
  async getConversationByChatId(chatId: string): Promise<Conversation | null> {
    const conversationId = conversationsByChatId.get(chatId);
    if (!conversationId) return null;
    return conversations.get(conversationId) || null;
  }

  /**
   * Add a message to the conversation
   */
  async addMessage(
    conversationId: string,
    message: Omit<ConversationMessage, 'id' | 'timestamp'>
  ): Promise<Conversation> {
    const conversation = conversations.get(conversationId);
    if (!conversation) {
      throw new Error(`Conversation not found: ${conversationId}`);
    }

    const newMessage: ConversationMessage = {
      id: uuid(),
      ...message,
      timestamp: new Date(),
    };

    conversation.messages.push(newMessage);
    conversation.lastMessageAt = newMessage.timestamp;
    conversation.lastMessageBy = message.role;
    conversation.updatedAt = new Date();

    // Update stage based on message
    if (message.role === 'candidate') {
      if (conversation.stage === 'awaiting_response' || conversation.stage === 'follow_up') {
        conversation.stage = 'in_conversation';
      }
    }

    return conversation;
  }

  /**
   * Generate Riley's response to an incoming message
   */
  async generateResponse(context: ResponseGenerationContext): Promise<GeneratedResponse> {
    const { conversation, incomingMessage, candidateProfile, jobContext, guidelines } = context;

    // Build the prompt for Claude
    const prompt = this.buildResponsePrompt(context);

    try {
      // Check for API key
      const apiKey = process.env.ANTHROPIC_API_KEY;
      if (!apiKey) {
        return {
          message: '',
          confidence: 0,
          reasoning: 'No Anthropic API key configured',
          requiresEscalation: true,
          escalationReason: 'API key not configured - cannot generate response',
        };
      }

      // Call Claude API
      const { Anthropic } = await import('@anthropic-ai/sdk');
      const client = new Anthropic({ apiKey });

      const response = await client.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1024,
        system: this.getSystemPrompt(guidelines),
        messages: [{ role: 'user', content: prompt }],
      });

      // Parse the response
      const textContent = response.content.find(block => block.type === 'text');
      const responseText = textContent ? (textContent as { type: 'text'; text: string }).text : '';

      // Try to parse as JSON (if we asked for structured output)
      try {
        const parsed = JSON.parse(responseText);
        return {
          message: parsed.message || '',
          confidence: parsed.confidence || 0.7,
          reasoning: parsed.reasoning || 'Generated response',
          suggestedStage: parsed.suggestedStage,
          requiresEscalation: parsed.requiresEscalation || false,
          escalationReason: parsed.escalationReason,
        };
      } catch {
        // Not JSON, treat as plain message
        return {
          message: responseText,
          confidence: 0.7,
          reasoning: 'Generated plain text response',
          requiresEscalation: false,
        };
      }
    } catch (error) {
      console.error('[ConversationService] Error generating response:', error);
      return {
        message: '',
        confidence: 0,
        reasoning: error instanceof Error ? error.message : 'Unknown error',
        requiresEscalation: true,
        escalationReason: 'Failed to generate AI response',
      };
    }
  }

  /**
   * Build the prompt for response generation
   */
  private buildResponsePrompt(context: ResponseGenerationContext): string {
    const { conversation, incomingMessage, candidateProfile, jobContext } = context;

    let prompt = `You are Riley, an AI recruiting agent responding to a candidate's message.

## Conversation Context
Candidate: ${conversation.candidateName}
${conversation.candidateTitle ? `Current Role: ${conversation.candidateTitle}` : ''}
${conversation.candidateCompany ? `Company: ${conversation.candidateCompany}` : ''}
Conversation Stage: ${conversation.stage}
Messages in thread: ${conversation.messages.length}

`;

    if (jobContext) {
      prompt += `## Role We're Discussing
Title: ${jobContext.title}
${jobContext.company ? `Company: ${jobContext.company}` : ''}
${jobContext.location ? `Location: ${jobContext.location}` : ''}
${jobContext.highlights?.length ? `Key Highlights:\n${jobContext.highlights.map(h => `- ${h}`).join('\n')}` : ''}

`;
    }

    if (candidateProfile?.summary) {
      prompt += `## Candidate Background
${candidateProfile.summary.substring(0, 500)}

`;
    }

    // Add recent message history
    const recentMessages = conversation.messages.slice(-5);
    if (recentMessages.length > 0) {
      prompt += `## Recent Messages
${recentMessages.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n\n')}

`;
    }

    prompt += `## Incoming Message from Candidate
"${incomingMessage}"

## Your Task
Generate an appropriate response. Consider:
1. What is the candidate asking or expressing?
2. What stage should this conversation move to?
3. Does this need human intervention (salary discussion, complaints, scheduling)?

Respond with JSON:
{
  "message": "Your response to the candidate",
  "confidence": 0.0-1.0,
  "reasoning": "Brief explanation of your response strategy",
  "suggestedStage": "in_conversation|scheduling|closed_interested|closed_not_interested",
  "requiresEscalation": true/false,
  "escalationReason": "If escalation needed, explain why"
}

Guidelines:
- Keep responses concise and professional but warm
- Don't discuss salary/compensation - escalate those
- Don't make scheduling commitments - escalate to human
- If candidate seems uninterested, acknowledge gracefully
- If unclear what they want, ask a clarifying question
`;

    return prompt;
  }

  /**
   * Get the system prompt for Riley's conversation style
   */
  private getSystemPrompt(guidelines?: ResponseGenerationContext['guidelines']): string {
    const voice = guidelines?.brandVoice || 'professional but warm';
    const avoidPhrases = guidelines?.avoidPhrases || [
      'exciting opportunity',
      'perfect fit',
      'I came across your profile',
    ];

    return `You are Riley, a skilled technical recruiter who is also a software engineer by trade.

## Your Voice
- ${voice}
- Natural and conversational, not corporate-speak
- Knowledgeable about technology and can discuss technical topics
- Respectful of the candidate's time

## Response Guidelines
- Keep messages concise (2-4 sentences typically)
- Address what the candidate actually said
- Don't be overly salesy or pushy
- If you're unsure, ask a clarifying question

## Avoid These Phrases
${avoidPhrases.map(p => `- "${p}"`).join('\n')}

## Escalation Rules
Always escalate (set requiresEscalation: true) when:
- Candidate asks about salary, compensation, equity
- Candidate wants to schedule an interview or call
- Candidate expresses concerns or complaints
- Candidate asks who you are or if you're a bot
- You're unsure how to respond appropriately

Remember: You're a recruiter, not a decision-maker. Your job is to engage candidates and hand off to humans for important decisions.`;
  }

  /**
   * Update conversation stage
   */
  async updateStage(conversationId: string, stage: ConversationStage): Promise<Conversation> {
    const conversation = conversations.get(conversationId);
    if (!conversation) {
      throw new Error(`Conversation not found: ${conversationId}`);
    }

    conversation.stage = stage;
    conversation.updatedAt = new Date();

    return conversation;
  }

  /**
   * Escalate conversation to teleoperator
   */
  async escalate(conversationId: string, reason: string): Promise<Conversation> {
    const conversation = conversations.get(conversationId);
    if (!conversation) {
      throw new Error(`Conversation not found: ${conversationId}`);
    }

    conversation.status = 'escalated';
    conversation.escalationReason = reason;
    conversation.updatedAt = new Date();

    console.log('[ConversationService] Escalated conversation:', {
      conversationId,
      candidateName: conversation.candidateName,
      reason,
    });

    return conversation;
  }

  /**
   * List all conversations with optional filters
   */
  async listConversations(filters?: {
    status?: Conversation['status'];
    stage?: ConversationStage;
    jobRequisitionId?: string;
  }): Promise<Conversation[]> {
    let results = Array.from(conversations.values());

    if (filters?.status) {
      results = results.filter(c => c.status === filters.status);
    }
    if (filters?.stage) {
      results = results.filter(c => c.stage === filters.stage);
    }
    if (filters?.jobRequisitionId) {
      results = results.filter(c => c.jobRequisitionId === filters.jobRequisitionId);
    }

    // Sort by last message time, most recent first
    results.sort((a, b) => b.lastMessageAt.getTime() - a.lastMessageAt.getTime());

    return results;
  }

  /**
   * Get conversation statistics
   */
  async getStats(): Promise<{
    total: number;
    byStatus: Record<string, number>;
    byStage: Record<string, number>;
    needingResponse: number;
    escalated: number;
  }> {
    const all = Array.from(conversations.values());

    const byStatus: Record<string, number> = {};
    const byStage: Record<string, number> = {};

    for (const conv of all) {
      byStatus[conv.status] = (byStatus[conv.status] || 0) + 1;
      byStage[conv.stage] = (byStage[conv.stage] || 0) + 1;
    }

    return {
      total: all.length,
      byStatus,
      byStage,
      needingResponse: all.filter(
        c => c.status === 'active' && c.lastMessageBy === 'candidate'
      ).length,
      escalated: all.filter(c => c.status === 'escalated').length,
    };
  }
}

// Export singleton instance
export const conversationService = new ConversationService();
